{"version":3,"sources":["webpack:///./src/views/mybackgarden/backgarden/interviewquestions/components/Anchor.vue?c150","webpack:///./src/views/mybackgarden/backgarden/interviewquestions/components/Anchor.vue?826d","webpack:///./src/views/mybackgarden/backgarden/interviewquestions/components/Anchor.vue","webpack:///./src/views/mybackgarden/backgarden/interviewquestions/components/Anchor.vue?62be","webpack:///./src/views/mybackgarden/backgarden/interviewquestions/index.vue","webpack:///./src/views/mybackgarden/backgarden/interviewquestions/index.vue?6335","webpack:///./src/views/mybackgarden/backgarden/interviewquestions/index.vue?4c77"],"names":["_hoisted_1","class","_hoisted_2","render","_ctx","_cache","$props","$setup","$data","$options","_openBlock","_createElementBlock","_createElementVNode","_Fragment","_renderList","anchorList","item","index","key","_normalizeClass","selectedAnchorId","id","onClick","$event","jumpTo","_toDisplayString","name","defineComponent","props","components","setup","ref","value","srcolls","document","getElementById","scrollIntoView","block","behavior","watch","propsSelectedAnchorId","__exports__","nextTick","scrollView","querySelector","anchorEle","getElementsByClassName","timer","addEventListener","ev","scrollTop","target","console","log","clearTimeout","setTimeout","forEach","selectItemOffsetTop","offsetTop","selectedClassName","className","split"],"mappings":"kHAAA,W,2DCEA,MACMA,EAAa,CAAEC,MAAO,mBACtBC,EAAa,CAAC,WAEd,SAAUC,EAAOC,EAAUC,EAAYC,EAAYC,EAAYC,EAAWC,GAC9E,OAAQC,yBAAcC,gCAAoB,MAAO,KAAM,CACrDC,gCAAoB,MAAOZ,EAAY,CACrCY,gCAAoB,KAAM,KAAM,EAC7BF,wBAAW,GAAOC,gCAAoBE,cAAW,KAAMC,wBAAYV,EAAKW,WAAY,CAACC,EAAMC,KAClFP,yBAAcC,gCAAoB,KAAM,CAC9CO,IAAKD,EACLhB,MAAOkB,4BAAgB,GAAGH,EAAKf,SAASG,EAAKgB,mBAAqBJ,EAAKK,IAAM,gBAC7EC,QAAUC,GAAiBnB,EAAKoB,OAAOR,EAAKK,KAC3CI,6BAAiBT,EAAKU,MAAO,GAAIxB,KAClC,YCPGyB,mCAAgB,CAC7BD,KAAM,UACNE,MAAO,CAAC,yBACRC,WAAY,GACZC,MAAMF,GACJ,MAAMR,EAAmBW,iBAAY,WAC/BhB,EAAagB,iBAAwB,CACzC,CACEV,GAAI,UACJK,KAAM,eACNzB,MAAO,eAET,CACEoB,GAAI,UACJK,KAAM,mBACNzB,MAAO,eAET,CACEoB,GAAI,UACJK,KAAM,SACNzB,MAAO,eAET,CACEoB,GAAI,UACJK,KAAM,sBACNzB,MAAO,eAET,CACEoB,GAAI,UACJK,KAAM,cACNzB,MAAO,eAET,CACEoB,GAAI,UACJK,KAAM,kBACNzB,MAAO,eAET,CACEoB,GAAI,UACJK,KAAM,YACNzB,MAAO,eAET,CACEoB,GAAI,UACJK,KAAM,SACNzB,MAAO,eAET,CACEoB,GAAI,UACJK,KAAM,SACNzB,MAAO,eAET,CACEoB,GAAI,WACJK,KAAM,YACNzB,MAAO,iBAGLuB,EAAUH,IACdD,EAAiBY,MAAQX,EAEzB,IAAIY,EAAUC,SAASC,eAAed,GAC/B,OAAPY,QAAO,IAAPA,KAASG,eAAe,CAAEC,MAAO,QAASC,SAAU,YAStD,OAPAC,mBACE,IAAMX,EAAMY,sBACXR,IACCZ,EAAiBY,MAAQA,IAItB,CACLZ,mBACAL,aACAS,a,iCC5EN,MAAMiB,EAA2B,IAAgB,EAAQ,CAAC,CAAC,SAAStC,GAAQ,CAAC,YAAY,qBAE1E,Q,osUC6Wf,MAAMiB,EAAmBW,iBAAI,W,OAE7BW,sBAAS,KACP,MAAMC,EAAaT,SAASU,cAAc,oCACpCC,EAAYX,SAASY,uBAAuB,aAClD,IAAIC,EAAQ,KACZJ,EAAWK,iBAAiB,UAAU,SAAUC,GAC9C,MAAMC,EAAYD,EAAGE,OAAOD,UACf,MAATH,IACFK,QAAQC,IAAI,OAEZC,aAAaP,IAGfA,EAAQQ,YAAW,WACjBV,EAAUW,QAASxC,IACjB,MAAMyC,EAAsBzC,EAAK0C,UACjC,GAAIR,EAAYO,GAAuB,IAAK,CAC1C,MAAME,EAAoB3C,EAAK4C,UAAUC,MAAM,KAAK,GACpDzC,EAAiBY,MAAQ2B,OAG5B,U,+3GCtYP,MAAM,EAA2B,IAAgB,EAAQ,CAAC,CAAC,YAAY,qBAExD,gB,2DCRf,W","file":"js/chunk-c6708ed6.9119afba.js","sourcesContent":["export * from \"-!../../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--11-oneOf-1-0!../../../../../../node_modules/css-loader/dist/cjs.js??ref--11-oneOf-1-1!../../../../../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../../../../../node_modules/postcss-loader/src/index.js??ref--11-oneOf-1-2!../../../../../../node_modules/less-loader/dist/cjs.js??ref--11-oneOf-1-3!../../../../../../node_modules/style-resources-loader/lib/index.js??ref--11-oneOf-1-4!../../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./Anchor.vue?vue&type=style&index=0&id=0b344fc6&scoped=true&lang=less\"","import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, normalizeClass as _normalizeClass, createElementVNode as _createElementVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-0b344fc6\"),n=n(),_popScopeId(),n)\nconst _hoisted_1 = { class: \"anchor-position\" }\nconst _hoisted_2 = [\"onClick\"]\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  return (_openBlock(), _createElementBlock(\"div\", null, [\n    _createElementVNode(\"div\", _hoisted_1, [\n      _createElementVNode(\"ul\", null, [\n        (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.anchorList, (item, index) => {\n          return (_openBlock(), _createElementBlock(\"li\", {\n            key: index,\n            class: _normalizeClass(`${item.class} ${_ctx.selectedAnchorId === item.id && 'item-click'}`),\n            onClick: ($event: any) => (_ctx.jumpTo(item.id))\n          }, _toDisplayString(item.name), 11, _hoisted_2))\n        }), 128))\n      ])\n    ])\n  ]))\n}","\nimport { defineComponent, ref, watch } from \"vue\";\n\ninterface anchorListParams {\n  name: string;\n  id: string;\n  class: string;\n}\n\nexport default defineComponent({\n  name: \"Measure\",\n  props: [\"propsSelectedAnchorId\"],\n  components: {},\n  setup(props) {\n    const selectedAnchorId = ref<string>(\"anchor1\");\n    const anchorList = ref<anchorListParams[]>([\n      {\n        id: \"anchor1\",\n        name: \"HTTP/HTTPS协议\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor2\",\n        name: \"vue和react相同点、不同点\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor3\",\n        name: \"js设计模式\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor4\",\n        name: \"在浏览器输入url敲击回车后发生了什么\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor5\",\n        name: \"vue数据双向绑定原理\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor6\",\n        name: \"（vue/react）组件传值\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor7\",\n        name: \"nodejs的了解\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor8\",\n        name: \"es6的了解\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor9\",\n        name: \"原型&原型链\",\n        class: \"anchor-item\",\n      },\n      {\n        id: \"anchor10\",\n        name: \"什么是虚拟 DOM\",\n        class: \"anchor-item\",\n      },\n    ]);\n    const jumpTo = (id: string) => {\n      selectedAnchorId.value = id;\n      // if (item.id === id) item.class = \"anchor-item item-click\";\n      let srcolls = document.getElementById(id);\n      srcolls?.scrollIntoView({ block: \"start\", behavior: \"smooth\" });\n    };\n    watch(\n      () => props.propsSelectedAnchorId as string,\n      (value) => {\n        selectedAnchorId.value = value;\n      }\n    );\n\n    return {\n      selectedAnchorId,\n      anchorList,\n      jumpTo,\n    };\n  },\n});\n","import { render } from \"./Anchor.vue?vue&type=template&id=0b344fc6&scoped=true&ts=true\"\nimport script from \"./Anchor.vue?vue&type=script&lang=ts\"\nexport * from \"./Anchor.vue?vue&type=script&lang=ts\"\n\nimport \"./Anchor.vue?vue&type=style&index=0&id=0b344fc6&scoped=true&lang=less\"\n\nimport exportComponent from \"/home/runner/work/io/io/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-0b344fc6\"]])\n\nexport default __exports__","<template>\n  <div class=\"page-container\" id=\"interview-questions-scroll-view\">\n    <div class=\"content\">\n      <Anchor :propsSelectedAnchorId=\"selectedAnchorId\" />\n      <h3 id=\"anchor1\" class=\"anchorele anchor1\">HTTP/HTTPS协议</h3>\n      <div class=\"wrapper\">\n        <p class=\"level2-title\">1.HTTP</p>\n        <div class=\"wrapper-content\">\n          超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。\n        </div>\n        <p class=\"level2-title\">1.1.HTTP特点</p>\n        <div class=\"wrapper-content\">\n          <ul>\n            <li>1.无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li>\n            <li>\n              2.无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。\n            </li>\n            <li>3.基于请求和响应：基本的特性，由客户端发起请求，服务端响应 简单快速、灵活</li>\n            <li>4.通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>\n          </ul>\n        </div>\n        <p class=\"level2-title\">2.HTTPS</p>\n        <div class=\"wrapper-content\">\n          <ul>\n            <li>HTTPS是身披SSL外壳的HTTP。</li>\n            <li>\n              HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。\n            </li>\n          </ul>\n        </div>\n        <p class=\"level2-title\">2.2.HTTPS特点</p>\n        <div class=\"wrapper-content\">\n          <ul>\n            <li>1.内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>\n            <li>2.验证身份：通过证书认证客户端访问的是自己的服务器</li>\n            <li>3.保护数据完整性：防止传输的内容被中间人冒充或者篡改</li>\n          </ul>\n        </div>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h3 id=\"anchor2\" class=\"anchorele anchor2\">vue和react相同点、不同点</h3>\n      <div class=\"wrapper\">\n        <p class=\"level2-title\">一、相同点</p>\n        <div class=\"wrapper-content\">\n          <ul>\n            <li>利用虚拟DOM实现快速渲染</li>\n            <li>轻量级</li>\n            <li>响应式组件</li>\n            <li>服务器端渲染</li>\n            <li>易于集成路由工具，打包工具以及状态管理工具</li>\n            <li>优秀的支持和社区</li>\n            <li>一切都是组件，组件实例之间可以通信并嵌套，并且都使用了Virtual Dom的思想。</li>\n          </ul>\n        </div>\n        <p class=\"level2-title\">二、不同点</p>\n        <div class=\"wrapper-content\">\n          <ul>\n            <li>\n              vue本质是MVVM框架，是由MVC发展而来的（双向数据流），React本质是前端组件化框架，是由后端组件化发展而来的（单向数据流）\n            </li>\n            <li>\n              vue是一个更小更灵活，适合开发单页面程序的简单化组件。 React是一个适合数据经常变化及构建大型项目的复杂组件\n            </li>\n          </ul>\n        </div>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h3 id=\"anchor3\" class=\"anchorele anchor3\">js设计模式</h3>\n      <div class=\"wrapper\">\n        <p class=\"level2-title\">1.单例模式</p>\n        <p class=\"level2-title\">2.策略模式</p>\n        <div class=\"wrapper-content\">定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</div>\n        <p class=\"level2-title\">3.代理模式</p>\n        <p class=\"level2-title\">4.迭代模式</p>\n        <div class=\"wrapper-content\">\n          迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n        </div>\n        <p class=\"level2-title\">5.发布—订阅模式</p>\n        <div class=\"wrapper-content\">\n          也称作观察者模式，定义了对象间的一种一对多的依赖关系，当一个对象的状态发\n          生改变时，所有依赖于它的对象都将得到通知\n        </div>\n        <v-md-preview\n          text=\"```js\n          // 订阅\n          document.body.addEventListener('click', function() { console.log('click1'); }, false);\n          document.body.addEventListener('click', function() { console.log('click2'); }, false);\n          // 发布\n          document.body.click(); // click1 click2\n          \"\n        ></v-md-preview>\n        <p class=\"level2-title\">6.命令模式</p>\n        <p class=\"level2-title\">7.组合模式</p>\n        <div class=\"wrapper-content\">\n          是用小的子对象来构建更大的 对象，而这些小的子对象本身也许是由更小 的“孙对象”构成的。\n        </div>\n        <p class=\"level2-title\">8.装饰者模式</p>\n        <div class=\"wrapper-content\">\n          以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。\n          是一种“即用即付”的方式，能够在不改变对 象自身的基础上，在程序运行期间给对象动态地 添加职责\n        </div>\n        <p class=\"level2-title\">9.状态模式</p>\n        <div class=\"wrapper-content\">\n          事物内部状态的改变往往会带来事物的行为改变。在处理的时候，将这个处理委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为\n        </div>\n        <p class=\"level2-title\">10.外观模式</p>\n        <div class=\"wrapper-content\">\n          为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使子系统更加容易使用\n        </div>\n        <v-md-preview\n          text=\"```js\n          // 三个处理函数\n          function start() {\n              console.log('start');\n          }\n\n          function doing() {\n              console.log('doing');\n          }\n\n          function end() {\n              console.log('end');\n          }\n\n          // 外观函数，将一些处理统一起来，方便调用\n          function execute() {\n              start();\n              doing();\n              end();\n          }\n\n          // 调用init开始执行\n          function init() {\n              // 此处直接调用了高层函数，也可以选择越过它直接调用相关的函数\n              execute();\n          }\n\n          init(); // start doing end\n          \"\n        ></v-md-preview>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h3 id=\"anchor4\" class=\"anchorele anchor4\">在浏览器输入url敲击回车后发生了什么</h3>\n      <div class=\"wrapper\">\n        <p class=\"level2-title\">概述</p>\n        在浏览器输入URL回车之后，主要发生以下六个行为：\n\n        <div>1、URL解析</div>\n        <div>2、域名解析</div>\n        <div>3、tcp连接</div>\n        <div>4、http请求</div>\n        <div>5、响应请求</div>\n        <div>6、页面渲染</div>\n\n        <p>\n          详细链接：<a href=\"https://www.jianshu.com/p/a0dbffd9bd43\" target=\"_blank\"\n            >https://www.jianshu.com/p/a0dbffd9bd43</a\n          >\n        </p>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h3 id=\"anchor5\" class=\"anchorele anchor5\">vue数据双向绑定原理</h3>\n      <div class=\"wrapper\">\n        <p class=\"level2-title\">一、原理分析</p>\n        <ul>\n          <li>1. new Vue() 首先执行初始化，对data执行响应化处理，这个过程发生在Observer中</li>\n          <li>2. 同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中</li>\n          <li>3. 同时定义一个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数</li>\n          <li>4. 由于data的某个key在一个视图中可能出现多次，所以每个key都需要一个管家Dep来管理多个Watcher</li>\n          <li>5. 将来data中数据一旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数</li>\n        </ul>\n        <p class=\"level2-title\">二、实现思路</p>\n        <ul>\n          <li>1. 监听数据变化（数据劫持/数据代理）[Object.defineProperty]</li>\n          <li>2. 收集视图依赖了哪些数据 （依赖收集）</li>\n          <li>3. 数据变化时，自动“通知”视图需要修改哪些部分，并进行更新 （发布订阅模式）</li>\n        </ul>\n        <p class=\"level2-title\">三、实现简单的双向绑定</p>\n\n        <v-md-preview\n          text=\"```js\n          <input type='text' id='input' />\n          <p id='data'></p>\n          <script>\n              const obj = {};\n              const input = document.getElementById('input');\n              // 数据劫持，实现数据->视图的绑定\n              Object.defineProperty(obj, 'name', {\n                  configurable: true,\n                  enumerable: true,\n                  get() {\n                      return input.value;\n                  },\n                  set(newVal) {\n                      input.value = newVal;\n                      document.getElementById('data').innerHTML = newVal;\n                  }\n               });\n              // 监听输入框，实现视图->数据的绑定\n              input.addEventListener('keyup', () => {\n                  obj.name = input.value;\n              })\n          </script>\n          \"\n        ></v-md-preview>\n      </div>\n    </div>\n\n    <div class=\"content\">\n      <h3 id=\"anchor6\" class=\"anchorele anchor6\">（vue/react）组件传值</h3>\n      <div class=\"wrapper\">\n        <p class=\"level2-title\">一、vue组件传值</p>\n        <p>1、父组件传给子组件</p>\n        <v-md-preview\n          text=\"```js\n           // Children.vue\n           props:['msg'],\n           data() {\n               return {\n                   myMsg:this.msg\n               }\n           }\n\n           // Parent.vue\n           <Children :msg='message'></Children>\n          \"\n        ></v-md-preview>\n        <p>2、子组件传给父组件</p>\n        <p>// 在子组件中使用this.$emit(‘myEvent’) 触发，然后在父组件中使用@myEvent监听</p>\n        <v-md-preview\n          text=\"```js\n         // Children.vue\n         // 通过自定义事件addNum把值传给父组件\n         this.$emit('addNum',this.childNum++)\n\n         // Parent.vue\n         <Children-Com @addNum='getNum'></Children-Com>\n         methods:{\n            // childNum是由子组件传入的\n            getNum(childNum){\n                this.parentNum = childNum\n            }\n          }\n        \"\n        ></v-md-preview>\n        <p>3、兄弟组价间传值</p>\n        <div>\n          <p>1.子组建A通过$emit监听自定义事件，向父组件传值，然后父组件再通过props将值传递给子组件</p>\n          <p>2.总线传值 $emit + $on</p>\n        </div>\n        <p>4、使用$ref传值</p>\n        <div>通过$ref的能力，给子组件定义一个ID，父组件通过这个ID可以直接访问子组件里面的方法和属性</div>\n        <p>5、使用依赖注入传给后代子孙曾孙</p>\n        <p>假设父组件有一个方法 getName()，需要把它提供给所有的后代</p>\n        <v-md-preview\n          text=\"```js\n          // provide 选项允许我们指定我们想要提供给后代组件的数据&方法\n\n          provide: function () {\n            return {\n              getName: this.getName()\n            }\n          }\n\n          // 然后在任何后代组件里，我们都可以使用 inject 来给当前实例注入父组件的数据/方法：\n\n          inject: ['getName']\n        \"\n        ></v-md-preview>\n        <p class=\"level2-title\">二、react组件传值</p>\n        <p><strong>组件传值的分类</strong></p>\n        <ul>\n          <li>1. 按嵌套关系分：父子传值和兄弟传值(意思是指跨组件传值)</li>\n          <li>2. 按传值方法分：props，ref，context，redux</li>\n        </ul>\n        <ul class=\"ul-disc\">\n          <li><strong>1、 父组件向子组件传值</strong></li>\n          <div>父组件向子组件传值 也是通过 props 来传，在子组件中用 this.props.xx 接收父组件传来的值</div>\n          <li><strong>2. 子组件向父组件传值</strong></li>\n          <div>通过 事件传递 + callback 实现</div>\n          <li><strong>3. 子组件向子组件传值（包括兄弟组件）</strong></li>\n          <div>\n            通过总线bus 、 bus.emit(‘xx’,{data})、 bus.on(‘xx’,data=>{}) 来传值；传值的组件用\n            bus.emit(‘xx’,{data})传值，接收值的组件用 bus.on(‘xx’,data=>{}) 来接收传来的值\n          </div>\n          <li><strong>4. 通过context上下文传值</strong></li>\n        </ul>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h3 id=\"anchor7\" class=\"anchorele anchor7\">nodejs的了解</h3>\n      <div class=\"wrapper\">\n        nodejs是一个基于ChromeV8引擎的JavaScript运行环境，一个让JavaScript运行在服务端的开发平台，让脚本语言JavaScript能作为服务器语言。\n        <p>node的优点：超强的高并发能力、使用JavaScript语法等。</p>\n        <ul class=\"ul-disc\">\n          <li>http用来处理请求响应的模块</li>\n          <li>fs 用来读取文件的模块</li>\n          <li>url 用来解析请求数据等等</li>\n          <li>Node.js还集成了 Npm 包管理工具，让我们可以很方便的通过命令行就能下载我们项目依赖的包</li>\n          <li>让前端工程模块化，开发迅速，降低代码耦合度，可维护性大大增强。</li>\n        </ul>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h3 id=\"anchor8\" class=\"anchorele anchor8\">es6的了解</h3>\n      <div class=\"wrapper\">\n        <ul class=\"ul-disc\">\n          <li>1. var、let、const各自的特点及其区别</li>\n          <br />\n          <pre>\n    在ES6之前只有全局作用域和局部作用域，ES6新增了块级作用域let和const,下面将简单介绍var、let和const的特点以及区别。\n    块级作用域：只能在声明的区域（代码块）中使用，不能在声明的区域的外部使用，否则报（xxx is not defined）。\n    var：使用var声明的变量，其作用域为该变量所在的函数内，且存在变量提升现象（变量提升：可以先使用再声明），不会受到块级作用域的影响\n    let：ES6新增的块级作用域\n    1：使用let声明的变量具有块级作用域:，只能在当前声明的代码块中使用，必须要先声明再使用\n    2：具有暂时性死区特性。 const：ES6中新增的常量（常量：值（内存地址）不可更改的量）。特点如下：\n\n    3.1：具有块级作用域的特点，只能在当前声明的代码块中使用，必须要先声明再使用。\n    3.2：声明常量时必须赋值，如果不赋值报错：Missing initializer in const declaration（在const声明中未初始化）。\n    3.3：const声明的常量不可更改。\n    3.4：使用const声明的常量如果是基本数据类型（比如：数字、字符串），一旦赋值，值不可以更改；\n    如果是引用数据类型（数组，对象），不能重新赋值，但是可以更改数据结构内部的值（比如修改对象中的属性）\n          </pre>\n          <li>2. 箭头函数</li>\n          <br />\n          <div>\n            <p>2.1、 箭头函数相当于匿名函数，并且简化了函数定义</p>\n            <p>2.2、 箭头函数没有原型prototype，因此箭头函数没有this指向</p>\n            <p>\n              2.3、\n              箭头函数没有自己的this指向，它会捕获自己定义所处的外层执行环境，并且继承这个this值。箭头函数的this指向在被定义的时候就确定了，之后永远都不会改变。\n            </p>\n          </div>\n        </ul>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h3 id=\"anchor9\" class=\"anchorele anchor9\">原型&原型链</h3>\n      <div class=\"wrapper\">\n        <p>\n          原型：每一个对象都有一个prototype属性可以挂载要扩展的属性和方法，在prototype上挂载的属性和方法在这个对象的任何实例上都可以调用。\n        </p>\n        <p>\n          当一个对象调用自身不存在的属性/方法时，就会去prototype关联的父类对象上去找，如果找不到继续去父类关联的对象上去找，直到找到Object的属性和方法，找到直到调用，找不到返回undefined\n        </p>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h3 id=\"anchor10\" class=\"anchorele anchor10\">什么是虚拟 DOM</h3>\n      <div class=\"wrapper\">\n        <p>一、 起源</p>\n        <div>虚拟dom最先是由facebook团队提出的，最先运用在react中，之后在vue2.0版本中引入了虚拟DOM的概念</div>\n        <p>二、 虚拟 DOM 实现原理</p>\n        <ul>\n          <li>\n            1. 用 JavaScript 对象结构表示 DOM 树的结构，比如说：一个元素对象，包含TagName、props 和\n            Children这些属性。然后根据这个对象构建一个真正的 DOM 节点， 插到文档当中；\n          </li>\n          <li>2. 当数据状态变更的时候，重新构造一棵新的对象树。通过diff 算法，比较新旧虚拟 DOM 树的差异。</li>\n          <li>3. 根据差异，对真正的 DOM 树进行增、删、改。</li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { nextTick, ref } from \"vue\";\nimport Anchor from \"./components/Anchor.vue\";\n\nconst selectedAnchorId = ref(\"anchor1\");\n\nnextTick(() => {\n  const scrollView = document.querySelector(\"#interview-questions-scroll-view\");\n  const anchorEle = document.getElementsByClassName(\"anchorele\");\n  let timer = null;\n  scrollView.addEventListener(\"scroll\", function (ev) {\n    const scrollTop = ev.target.scrollTop;\n    if (timer != null) {\n      console.log(\"节流中\");\n      // 一直清除定时器\n      clearTimeout(timer);\n    }\n    // 只有最后一次定时器有效执行\n    timer = setTimeout(function () {\n      anchorEle.forEach((item) => {\n        const selectItemOffsetTop = item.offsetTop;\n        if (scrollTop - selectItemOffsetTop > -251) {\n          const selectedClassName = item.className.split(\" \")[1];\n          selectedAnchorId.value = selectedClassName;\n        }\n      });\n    }, 500);\n  });\n  //节流函数\n});\n</script>\n\n<style lang=\"less\" scoped>\nh3 {\n  color: red;\n}\nul {\n  list-style-type: none;\n}\n.ul-disc {\n  list-style-type: disc;\n}\n.page-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  overflow-y: scroll;\n  padding: 30px;\n  .content {\n    .wrapper {\n      padding: 10px 10px 10px 40px;\n      .level2-title {\n        font-weight: bolder;\n        letter-spacing: 2px;\n      }\n      .wrapper-content {\n        text-indent: 2em;\n      }\n    }\n  }\n}\n</style>\n","import script from \"./index.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./index.vue?vue&type=script&setup=true&lang=js\"\n\nimport \"./index.vue?vue&type=style&index=0&id=3693f1d1&lang=less&scoped=true\"\n\nimport exportComponent from \"/home/runner/work/io/io/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-3693f1d1\"]])\n\nexport default __exports__","export * from \"-!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--11-oneOf-1-0!../../../../../node_modules/css-loader/dist/cjs.js??ref--11-oneOf-1-1!../../../../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../../../../node_modules/postcss-loader/src/index.js??ref--11-oneOf-1-2!../../../../../node_modules/less-loader/dist/cjs.js??ref--11-oneOf-1-3!../../../../../node_modules/style-resources-loader/lib/index.js??ref--11-oneOf-1-4!../../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./index.vue?vue&type=style&index=0&id=3693f1d1&lang=less&scoped=true\""],"sourceRoot":""}