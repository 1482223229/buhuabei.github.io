(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-36558076"],{1276:function(e,t,a){"use strict";var n=a("d784"),l=a("44e7"),c=a("825a"),i=a("1d80"),d=a("4840"),r=a("8aa5"),o=a("50c4"),s=a("14c3"),v=a("9263"),u=a("9f7f"),p=a("d039"),h=u.UNSUPPORTED_Y,m=[].push,f=Math.min,b=4294967295,j=!p((function(){var e=/(?:)/,t=e.exec;e.exec=function(){return t.apply(this,arguments)};var a="ab".split(e);return 2!==a.length||"a"!==a[0]||"b"!==a[1]}));n("split",(function(e,t,a){var n;return n="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(e,a){var n=String(i(this)),c=void 0===a?b:a>>>0;if(0===c)return[];if(void 0===e)return[n];if(!l(e))return t.call(n,e,c);var d,r,o,s=[],u=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),p=0,h=new RegExp(e.source,u+"g");while(d=v.call(h,n)){if(r=h.lastIndex,r>p&&(s.push(n.slice(p,d.index)),d.length>1&&d.index<n.length&&m.apply(s,d.slice(1)),o=d[0].length,p=r,s.length>=c))break;h.lastIndex===d.index&&h.lastIndex++}return p===n.length?!o&&h.test("")||s.push(""):s.push(n.slice(p)),s.length>c?s.slice(0,c):s}:"0".split(void 0,0).length?function(e,a){return void 0===e&&0===a?[]:t.call(this,e,a)}:t,[function(t,a){var l=i(this),c=void 0==t?void 0:t[e];return void 0!==c?c.call(t,l,a):n.call(String(l),t,a)},function(e,l){var i=a(n,this,e,l,n!==t);if(i.done)return i.value;var v=c(this),u=String(e),p=d(v,RegExp),m=v.unicode,j=(v.ignoreCase?"i":"")+(v.multiline?"m":"")+(v.unicode?"u":"")+(h?"g":"y"),g=new p(h?"^(?:"+v.source+")":v,j),O=void 0===l?b:l>>>0;if(0===O)return[];if(0===u.length)return null===s(g,u)?[u]:[];var N=0,w=0,V=[];while(w<u.length){g.lastIndex=h?0:w;var E,T=s(g,h?u.slice(w):u);if(null===T||(E=f(o(g.lastIndex+(h?w:0)),u.length))===N)w=r(u,w,m);else{if(V.push(u.slice(N,w)),V.length===O)return V;for(var S=1;S<=T.length-1;S++)if(V.push(T[S]),V.length===O)return V;w=N=E}}return V.push(u.slice(N)),V}]}),!j,h)},"1d65":function(e,t,a){"use strict";a("80e2")},"7f26":function(e,t,a){"use strict";a.r(t);a("a630"),a("3ca3"),a("159b"),a("ac1f"),a("1276");var n=a("7a23"),l=(a("99af"),a("b0c0"),{class:"anchor-position"}),c=["onClick"];function i(e,t,a,i,d,r){return Object(n["openBlock"])(),Object(n["createElementBlock"])("div",null,[Object(n["createElementVNode"])("div",l,[Object(n["createElementVNode"])("ul",null,[(Object(n["openBlock"])(!0),Object(n["createElementBlock"])(n["Fragment"],null,Object(n["renderList"])(e.anchorList,(function(t,a){return Object(n["openBlock"])(),Object(n["createElementBlock"])("li",{key:a,class:Object(n["normalizeClass"])("".concat(t.class," ").concat(e.selectedAnchorId===t.id&&"item-click")),onClick:function(a){return e.jumpTo(t.id)}},Object(n["toDisplayString"])(t.name),11,c)})),128))])])])}var d=Object(n["defineComponent"])({name:"Measure",props:["propsSelectedAnchorId"],components:{},setup:function(e){var t=Object(n["ref"])("anchor1"),a=Object(n["ref"])([{id:"anchor1",name:"HTTP/HTTPS协议",class:"anchor-item"},{id:"anchor2",name:"vue和react相同点、不同点",class:"anchor-item"},{id:"anchor3",name:"js设计模式",class:"anchor-item"},{id:"anchor4",name:"在浏览器输入url敲击回车后发生了什么",class:"anchor-item"},{id:"anchor5",name:"vue数据双向绑定原理",class:"anchor-item"},{id:"anchor6",name:"（vue/react）组件传值",class:"anchor-item"},{id:"anchor7",name:"nodejs的了解",class:"anchor-item"},{id:"anchor8",name:"es6的了解",class:"anchor-item"},{id:"anchor9",name:"原型&原型链",class:"anchor-item"},{id:"anchor10",name:"什么是虚拟 DOM",class:"anchor-item"}]),l=function(e){t.value=e;var a=document.getElementById(e);null===a||void 0===a||a.scrollIntoView({block:"start",behavior:"smooth"})};return Object(n["watch"])((function(){return e.propsSelectedAnchorId}),(function(e){t.value=e})),{selectedAnchorId:t,anchorList:a,jumpTo:l}}});a("1d65");d.render=i,d.__scopeId="data-v-0b344fc6";var r=d,o=function(e){return Object(n["pushScopeId"])("data-v-1e08834e"),e=e(),Object(n["popScopeId"])(),e},s={class:"page-container",id:"interview-questions-scroll-view"},v={class:"content"},u=Object(n["createStaticVNode"])('<h3 id="anchor1" class="anchorele anchor1" data-v-1e08834e>HTTP/HTTPS协议</h3><div class="wrapper" data-v-1e08834e><p class="level2-title" data-v-1e08834e>1.HTTP</p><div class="wrapper-content" data-v-1e08834e> 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。 </div><p class="level2-title" data-v-1e08834e>1.1.HTTP特点</p><div class="wrapper-content" data-v-1e08834e><ul data-v-1e08834e><li data-v-1e08834e>1.无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li><li data-v-1e08834e> 2.无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。 </li><li data-v-1e08834e>3.基于请求和响应：基本的特性，由客户端发起请求，服务端响应 简单快速、灵活</li><li data-v-1e08834e>4.通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li></ul></div><p class="level2-title" data-v-1e08834e>2.HTTPS</p><div class="wrapper-content" data-v-1e08834e><ul data-v-1e08834e><li data-v-1e08834e>HTTPS是身披SSL外壳的HTTP。</li><li data-v-1e08834e> HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。 </li></ul></div><p class="level2-title" data-v-1e08834e>2.2.HTTPS特点</p><div class="wrapper-content" data-v-1e08834e><ul data-v-1e08834e><li data-v-1e08834e>1.内容加密：采用混合加密技术，中间者无法直接查看明文内容</li><li data-v-1e08834e>2.验证身份：通过证书认证客户端访问的是自己的服务器</li><li data-v-1e08834e>3.保护数据完整性：防止传输的内容被中间人冒充或者篡改</li></ul></div></div>',2),p=Object(n["createStaticVNode"])('<div class="content" data-v-1e08834e><h3 id="anchor2" class="anchorele anchor2" data-v-1e08834e>vue和react相同点、不同点</h3><div class="wrapper" data-v-1e08834e><p class="level2-title" data-v-1e08834e>一、相同点</p><div class="wrapper-content" data-v-1e08834e><ul data-v-1e08834e><li data-v-1e08834e>利用虚拟DOM实现快速渲染</li><li data-v-1e08834e>轻量级</li><li data-v-1e08834e>响应式组件</li><li data-v-1e08834e>服务器端渲染</li><li data-v-1e08834e>易于集成路由工具，打包工具以及状态管理工具</li><li data-v-1e08834e>优秀的支持和社区</li><li data-v-1e08834e>一切都是组件，组件实例之间可以通信并嵌套，并且都使用了Virtual Dom的思想。</li></ul></div><p class="level2-title" data-v-1e08834e>二、不同点</p><div class="wrapper-content" data-v-1e08834e><ul data-v-1e08834e><li data-v-1e08834e> vue本质是MVVM框架，是由MVC发展而来的（双向数据流），React本质是前端组件化框架，是由后端组件化发展而来的（单向数据流） </li><li data-v-1e08834e> vue是一个更小更灵活，适合开发单页面程序的简单化组件。 React是一个适合数据经常变化及构建大型项目的复杂组件 </li></ul></div></div></div>',1),h={class:"content"},m=o((function(){return Object(n["createElementVNode"])("h3",{id:"anchor3",class:"anchorele anchor3"},"js设计模式",-1)})),f={class:"wrapper"},b=Object(n["createStaticVNode"])('<p class="level2-title" data-v-1e08834e>1.单例模式</p><p class="level2-title" data-v-1e08834e>2.策略模式</p><div class="wrapper-content" data-v-1e08834e>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</div><p class="level2-title" data-v-1e08834e>3.代理模式</p><p class="level2-title" data-v-1e08834e>4.迭代模式</p><div class="wrapper-content" data-v-1e08834e> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 </div><p class="level2-title" data-v-1e08834e>5.发布—订阅模式</p><div class="wrapper-content" data-v-1e08834e> 也称作观察者模式，定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知 </div>',8),j=Object(n["createStaticVNode"])('<p class="level2-title" data-v-1e08834e>6.命令模式</p><p class="level2-title" data-v-1e08834e>7.组合模式</p><div class="wrapper-content" data-v-1e08834e> 是用小的子对象来构建更大的 对象，而这些小的子对象本身也许是由更小 的“孙对象”构成的。 </div><p class="level2-title" data-v-1e08834e>8.装饰者模式</p><div class="wrapper-content" data-v-1e08834e> 以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。 是一种“即用即付”的方式，能够在不改变对 象自身的基础上，在程序运行期间给对象动态地 添加职责 </div><p class="level2-title" data-v-1e08834e>9.状态模式</p><div class="wrapper-content" data-v-1e08834e> 事物内部状态的改变往往会带来事物的行为改变。在处理的时候，将这个处理委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为 </div><p class="level2-title" data-v-1e08834e>10.外观模式</p><div class="wrapper-content" data-v-1e08834e> 为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使子系统更加容易使用 </div>',9),g=Object(n["createStaticVNode"])('<div class="content" data-v-1e08834e><h3 id="anchor4" class="anchorele anchor4" data-v-1e08834e>在浏览器输入url敲击回车后发生了什么</h3><div class="wrapper" data-v-1e08834e><p class="level2-title" data-v-1e08834e>概述</p> 在浏览器输入URL回车之后，主要发生以下六个行为： <div data-v-1e08834e>1、URL解析</div><div data-v-1e08834e>2、域名解析</div><div data-v-1e08834e>3、tcp连接</div><div data-v-1e08834e>4、http请求</div><div data-v-1e08834e>5、响应请求</div><div data-v-1e08834e>6、页面渲染</div><p data-v-1e08834e> 详细链接：<a href="https://www.jianshu.com/p/a0dbffd9bd43" target="_blank" data-v-1e08834e>https://www.jianshu.com/p/a0dbffd9bd43</a></p></div></div>',1),O={class:"content"},N=o((function(){return Object(n["createElementVNode"])("h3",{id:"anchor5",class:"anchorele anchor5"},"vue数据双向绑定原理",-1)})),w={class:"wrapper"},V=Object(n["createStaticVNode"])('<p class="level2-title" data-v-1e08834e>一、原理分析</p><ul data-v-1e08834e><li data-v-1e08834e>1. new Vue() 首先执行初始化，对data执行响应化处理，这个过程发生在Observer中</li><li data-v-1e08834e>2. 同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中</li><li data-v-1e08834e>3. 同时定义一个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数</li><li data-v-1e08834e>4. 由于data的某个key在一个视图中可能出现多次，所以每个key都需要一个管家Dep来管理多个Watcher</li><li data-v-1e08834e>5. 将来data中数据一旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数</li></ul><p class="level2-title" data-v-1e08834e>二、实现思路</p><ul data-v-1e08834e><li data-v-1e08834e>1. 监听数据变化（数据劫持/数据代理）[Object.defineProperty]</li><li data-v-1e08834e>2. 收集视图依赖了哪些数据 （依赖收集）</li><li data-v-1e08834e>3. 数据变化时，自动“通知”视图需要修改哪些部分，并进行更新 （发布订阅模式）</li></ul><p class="level2-title" data-v-1e08834e>三、实现简单的双向绑定</p>',5),E={class:"content"},T=o((function(){return Object(n["createElementVNode"])("h3",{id:"anchor6",class:"anchorele anchor6"},"（vue/react）组件传值",-1)})),S={class:"wrapper"},x=o((function(){return Object(n["createElementVNode"])("p",{class:"level2-title"},"一、vue组件传值",-1)})),k=o((function(){return Object(n["createElementVNode"])("p",null,"1、父组件传给子组件",-1)})),y=o((function(){return Object(n["createElementVNode"])("p",null,"2、子组件传给父组件",-1)})),P=o((function(){return Object(n["createElementVNode"])("p",null,"// 在子组件中使用this.$emit(‘myEvent’) 触发，然后在父组件中使用@myEvent监听",-1)})),C=o((function(){return Object(n["createElementVNode"])("p",null,"3、兄弟组价间传值",-1)})),I=o((function(){return Object(n["createElementVNode"])("div",null,[Object(n["createElementVNode"])("p",null,"1.子组建A通过$emit监听自定义事件，向父组件传值，然后父组件再通过props将值传递给子组件"),Object(n["createElementVNode"])("p",null,"2.总线传值 $emit + $on")],-1)})),M=o((function(){return Object(n["createElementVNode"])("p",null,"4、使用$ref传值",-1)})),H=o((function(){return Object(n["createElementVNode"])("div",null,"通过$ref的能力，给子组件定义一个ID，父组件通过这个ID可以直接访问子组件里面的方法和属性",-1)})),D=o((function(){return Object(n["createElementVNode"])("p",null,"5、使用依赖注入传给后代子孙曾孙",-1)})),L=o((function(){return Object(n["createElementVNode"])("p",null,"假设父组件有一个方法 getName()，需要把它提供给所有的后代",-1)})),B=Object(n["createStaticVNode"])('<p class="level2-title" data-v-1e08834e>二、react组件传值</p><p data-v-1e08834e><strong data-v-1e08834e>组件传值的分类</strong></p><ul data-v-1e08834e><li data-v-1e08834e>1. 按嵌套关系分：父子传值和兄弟传值(意思是指跨组件传值)</li><li data-v-1e08834e>2. 按传值方法分：props，ref，context，redux</li></ul><ul class="ul-disc" data-v-1e08834e><li data-v-1e08834e><strong data-v-1e08834e>1、 父组件向子组件传值</strong></li><div data-v-1e08834e>父组件向子组件传值 也是通过 props 来传，在子组件中用 this.props.xx 接收父组件传来的值</div><li data-v-1e08834e><strong data-v-1e08834e>2. 子组件向父组件传值</strong></li><div data-v-1e08834e>通过 事件传递 + callback 实现</div><li data-v-1e08834e><strong data-v-1e08834e>3. 子组件向子组件传值（包括兄弟组件）</strong></li><div data-v-1e08834e> 通过总线bus 、 bus.emit(‘xx’,{data})、 bus.on(‘xx’,data=&gt;{}) 来传值；传值的组件用 bus.emit(‘xx’,{data})传值，接收值的组件用 bus.on(‘xx’,data=&gt;{}) 来接收传来的值 </div><li data-v-1e08834e><strong data-v-1e08834e>4. 通过context上下文传值</strong></li></ul>',4),A=Object(n["createStaticVNode"])('<div class="content" data-v-1e08834e><h3 id="anchor7" class="anchorele anchor7" data-v-1e08834e>nodejs的了解</h3><div class="wrapper" data-v-1e08834e> nodejs是一个基于ChromeV8引擎的JavaScript运行环境，一个让JavaScript运行在服务端的开发平台，让脚本语言JavaScript能作为服务器语言。 <p data-v-1e08834e>node的优点：超强的高并发能力、使用JavaScript语法等。</p><ul class="ul-disc" data-v-1e08834e><li data-v-1e08834e>http用来处理请求响应的模块</li><li data-v-1e08834e>fs 用来读取文件的模块</li><li data-v-1e08834e>url 用来解析请求数据等等</li><li data-v-1e08834e>Node.js还集成了 Npm 包管理工具，让我们可以很方便的通过命令行就能下载我们项目依赖的包</li><li data-v-1e08834e>让前端工程模块化，开发迅速，降低代码耦合度，可维护性大大增强。</li></ul></div></div><div class="content" data-v-1e08834e><h3 id="anchor8" class="anchorele anchor8" data-v-1e08834e>es6的了解</h3><div class="wrapper" data-v-1e08834e><ul class="ul-disc" data-v-1e08834e><li data-v-1e08834e>1. var、let、const各自的特点及其区别</li><br data-v-1e08834e><pre data-v-1e08834e>    在ES6之前只有全局作用域和局部作用域，ES6新增了块级作用域let和const,下面将简单介绍var、let和const的特点以及区别。\n    块级作用域：只能在声明的区域（代码块）中使用，不能在声明的区域的外部使用，否则报（xxx is not defined）。\n    var：使用var声明的变量，其作用域为该变量所在的函数内，且存在变量提升现象（变量提升：可以先使用再声明），不会受到块级作用域的影响\n    let：ES6新增的块级作用域\n    1：使用let声明的变量具有块级作用域:，只能在当前声明的代码块中使用，必须要先声明再使用\n    2：具有暂时性死区特性。 const：ES6中新增的常量（常量：值（内存地址）不可更改的量）。特点如下：\n\n    3.1：具有块级作用域的特点，只能在当前声明的代码块中使用，必须要先声明再使用。\n    3.2：声明常量时必须赋值，如果不赋值报错：Missing initializer in const declaration（在const声明中未初始化）。\n    3.3：const声明的常量不可更改。\n    3.4：使用const声明的常量如果是基本数据类型（比如：数字、字符串），一旦赋值，值不可以更改；\n    如果是引用数据类型（数组，对象），不能重新赋值，但是可以更改数据结构内部的值（比如修改对象中的属性）\n          </pre><li data-v-1e08834e>2. 箭头函数</li><br data-v-1e08834e><div data-v-1e08834e><p data-v-1e08834e>2.1、 箭头函数相当于匿名函数，并且简化了函数定义</p><p data-v-1e08834e>2.2、 箭头函数没有原型prototype，因此箭头函数没有this指向</p><p data-v-1e08834e> 2.3、 箭头函数没有自己的this指向，它会捕获自己定义所处的外层执行环境，并且继承这个this值。箭头函数的this指向在被定义的时候就确定了，之后永远都不会改变。 </p></div></ul></div></div><div class="content" data-v-1e08834e><h3 id="anchor9" class="anchorele anchor9" data-v-1e08834e>原型&amp;原型链</h3><div class="wrapper" data-v-1e08834e><p data-v-1e08834e> 原型：每一个对象都有一个prototype属性可以挂载要扩展的属性和方法，在prototype上挂载的属性和方法在这个对象的任何实例上都可以调用。 </p><p data-v-1e08834e> 当一个对象调用自身不存在的属性/方法时，就会去prototype关联的父类对象上去找，如果找不到继续去父类关联的对象上去找，直到找到Object的属性和方法，找到直到调用，找不到返回undefined </p></div></div><div class="content" data-v-1e08834e><h3 id="anchor10" class="anchorele anchor10" data-v-1e08834e>什么是虚拟 DOM</h3><div class="wrapper" data-v-1e08834e><p data-v-1e08834e>一、 起源</p><div data-v-1e08834e>虚拟dom最先是由facebook团队提出的，最先运用在react中，之后在vue2.0版本中引入了虚拟DOM的概念</div><p data-v-1e08834e>二、 虚拟 DOM 实现原理</p><ul data-v-1e08834e><li data-v-1e08834e> 1. 用 JavaScript 对象结构表示 DOM 树的结构，比如说：一个元素对象，包含TagName、props 和 Children这些属性。然后根据这个对象构建一个真正的 DOM 节点， 插到文档当中； </li><li data-v-1e08834e>2. 当数据状态变更的时候，重新构造一棵新的对象树。通过diff 算法，比较新旧虚拟 DOM 树的差异。</li><li data-v-1e08834e>3. 根据差异，对真正的 DOM 树进行增、删、改。</li></ul></div></div>',4),J={setup:function(e){var t=Object(n["ref"])("anchor1");return Object(n["nextTick"])((function(){var e=document.querySelector("#interview-questions-scroll-view"),a=document.getElementsByClassName("anchorele");a=Array.from(a);var n=null;e.addEventListener("scroll",(function(e){var l=e.target.scrollTop;null!=n&&(console.log("节流中"),clearTimeout(n)),n=setTimeout((function(){a.forEach((function(e){var a=e.offsetTop;if(l-a>-251){var n=e.className.split(" ")[1];t.value=n}}))}),500)}))})),function(e,a){var l=Object(n["resolveComponent"])("v-md-preview");return Object(n["openBlock"])(),Object(n["createElementBlock"])("div",s,[Object(n["createElementVNode"])("div",v,[Object(n["createVNode"])(r,{propsSelectedAnchorId:t.value},null,8,["propsSelectedAnchorId"]),u]),p,Object(n["createElementVNode"])("div",h,[m,Object(n["createElementVNode"])("div",f,[b,Object(n["createVNode"])(l,{text:"```js\n          // 订阅\n          document.body.addEventListener('click', function() { console.log('click1'); }, false);\n          document.body.addEventListener('click', function() { console.log('click2'); }, false);\n          // 发布\n          document.body.click(); // click1 click2\n          "}),j,Object(n["createVNode"])(l,{text:"```js\n          // 三个处理函数\n          function start() {\n              console.log('start');\n          }\n\n          function doing() {\n              console.log('doing');\n          }\n\n          function end() {\n              console.log('end');\n          }\n\n          // 外观函数，将一些处理统一起来，方便调用\n          function execute() {\n              start();\n              doing();\n              end();\n          }\n\n          // 调用init开始执行\n          function init() {\n              // 此处直接调用了高层函数，也可以选择越过它直接调用相关的函数\n              execute();\n          }\n\n          init(); // start doing end\n          "})])]),g,Object(n["createElementVNode"])("div",O,[N,Object(n["createElementVNode"])("div",w,[V,Object(n["createVNode"])(l,{text:"```js\n          <input type='text' id='input' />\n          <p id='data'></p>\n          <script>\n              const obj = {};\n              const input = document.getElementById('input');\n              // 数据劫持，实现数据->视图的绑定\n              Object.defineProperty(obj, 'name', {\n                  configurable: true,\n                  enumerable: true,\n                  get() {\n                      return input.value;\n                  },\n                  set(newVal) {\n                      input.value = newVal;\n                      document.getElementById('data').innerHTML = newVal;\n                  }\n               });\n              // 监听输入框，实现视图->数据的绑定\n              input.addEventListener('keyup', () => {\n                  obj.name = input.value;\n              })\n          <\/script>\n          "})])]),Object(n["createElementVNode"])("div",E,[T,Object(n["createElementVNode"])("div",S,[x,k,Object(n["createVNode"])(l,{text:"```js\n           // Children.vue\n           props:['msg'],\n           data() {\n               return {\n                   myMsg:this.msg\n               }\n           }\n\n           // Parent.vue\n           <Children :msg='message'></Children>\n          "}),y,P,Object(n["createVNode"])(l,{text:"```js\n         // Children.vue\n         // 通过自定义事件addNum把值传给父组件\n         this.$emit('addNum',this.childNum++)\n\n         // Parent.vue\n         <Children-Com @addNum='getNum'></Children-Com>\n         methods:{\n            // childNum是由子组件传入的\n            getNum(childNum){\n                this.parentNum = childNum\n            }\n          }\n        "}),C,I,M,H,D,L,Object(n["createVNode"])(l,{text:"```js\n          // provide 选项允许我们指定我们想要提供给后代组件的数据&方法\n\n          provide: function () {\n            return {\n              getName: this.getName()\n            }\n          }\n\n          // 然后在任何后代组件里，我们都可以使用 inject 来给当前实例注入父组件的数据/方法：\n\n          inject: ['getName']\n        "}),B])]),A])}}};a("a45d");J.__scopeId="data-v-1e08834e";t["default"]=J},"80e2":function(e,t,a){},"99af":function(e,t,a){"use strict";var n=a("23e7"),l=a("d039"),c=a("e8b5"),i=a("861d"),d=a("7b0b"),r=a("50c4"),o=a("8418"),s=a("65f0"),v=a("1dde"),u=a("b622"),p=a("2d00"),h=u("isConcatSpreadable"),m=9007199254740991,f="Maximum allowed index exceeded",b=p>=51||!l((function(){var e=[];return e[h]=!1,e.concat()[0]!==e})),j=v("concat"),g=function(e){if(!i(e))return!1;var t=e[h];return void 0!==t?!!t:c(e)},O=!b||!j;n({target:"Array",proto:!0,forced:O},{concat:function(e){var t,a,n,l,c,i=d(this),v=s(i,0),u=0;for(t=-1,n=arguments.length;t<n;t++)if(c=-1===t?i:arguments[t],g(c)){if(l=r(c.length),u+l>m)throw TypeError(f);for(a=0;a<l;a++,u++)a in c&&o(v,u,c[a])}else{if(u>=m)throw TypeError(f);o(v,u++,c)}return v.length=u,v}})},a45d:function(e,t,a){"use strict";a("a9a0")},a9a0:function(e,t,a){}}]);
//# sourceMappingURL=chunk-36558076.50a59b62.js.map